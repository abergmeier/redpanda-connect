// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AppRoleDeleteBindSecretID invokes app-role-delete-bind-secret-id operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/bind-secret-id
	AppRoleDeleteBindSecretID(ctx context.Context, params AppRoleDeleteBindSecretIDParams) error
	// AppRoleDeleteBoundCidrList invokes app-role-delete-bound-cidr-list operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/bound-cidr-list
	AppRoleDeleteBoundCidrList(ctx context.Context, params AppRoleDeleteBoundCidrListParams) error
	// AppRoleDeletePeriod invokes app-role-delete-period operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/period
	AppRoleDeletePeriod(ctx context.Context, params AppRoleDeletePeriodParams) error
	// AppRoleDeletePolicies invokes app-role-delete-policies operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/policies
	AppRoleDeletePolicies(ctx context.Context, params AppRoleDeletePoliciesParams) error
	// AppRoleDeleteRole invokes app-role-delete-role operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}
	AppRoleDeleteRole(ctx context.Context, params AppRoleDeleteRoleParams) error
	// AppRoleDeleteSecretIDBoundCidrs invokes app-role-delete-secret-id-bound-cidrs operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs
	AppRoleDeleteSecretIDBoundCidrs(ctx context.Context, params AppRoleDeleteSecretIDBoundCidrsParams) error
	// AppRoleDeleteSecretIDNumUses invokes app-role-delete-secret-id-num-uses operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses
	AppRoleDeleteSecretIDNumUses(ctx context.Context, params AppRoleDeleteSecretIDNumUsesParams) error
	// AppRoleDeleteSecretIDTTL invokes app-role-delete-secret-id-ttl operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-ttl
	AppRoleDeleteSecretIDTTL(ctx context.Context, params AppRoleDeleteSecretIDTTLParams) error
	// AppRoleDeleteTokenBoundCidrs invokes app-role-delete-token-bound-cidrs operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs
	AppRoleDeleteTokenBoundCidrs(ctx context.Context, params AppRoleDeleteTokenBoundCidrsParams) error
	// AppRoleDeleteTokenMaxTTL invokes app-role-delete-token-max-ttl operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/token-max-ttl
	AppRoleDeleteTokenMaxTTL(ctx context.Context, params AppRoleDeleteTokenMaxTTLParams) error
	// AppRoleDeleteTokenNumUses invokes app-role-delete-token-num-uses operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/token-num-uses
	AppRoleDeleteTokenNumUses(ctx context.Context, params AppRoleDeleteTokenNumUsesParams) error
	// AppRoleDeleteTokenTTL invokes app-role-delete-token-ttl operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/token-ttl
	AppRoleDeleteTokenTTL(ctx context.Context, params AppRoleDeleteTokenTTLParams) error
	// AppRoleDestroySecretID invokes app-role-destroy-secret-id operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/secret-id/destroy
	AppRoleDestroySecretID(ctx context.Context, request *AppRoleDestroySecretIdRequest, params AppRoleDestroySecretIDParams) error
	// AppRoleDestroySecretIDByAccessor invokes app-role-destroy-secret-id-by-accessor operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy
	AppRoleDestroySecretIDByAccessor(ctx context.Context, request *AppRoleDestroySecretIdByAccessorRequest, params AppRoleDestroySecretIDByAccessorParams) error
	// AppRoleDestroySecretIDByAccessor2 invokes app-role-destroy-secret-id-by-accessor2 operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy
	AppRoleDestroySecretIDByAccessor2(ctx context.Context, params AppRoleDestroySecretIDByAccessor2Params) error
	// AppRoleDestroySecretId2 invokes app-role-destroy-secret-id2 operation.
	//
	// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id/destroy
	AppRoleDestroySecretId2(ctx context.Context, params AppRoleDestroySecretId2Params) error
	// AppRoleListRoles invokes app-role-list-roles operation.
	//
	// GET /auth/{approle_mount_path}/role/
	AppRoleListRoles(ctx context.Context, params AppRoleListRolesParams) (*StandardListResponse, error)
	// AppRoleListSecretIds invokes app-role-list-secret-ids operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/secret-id/
	AppRoleListSecretIds(ctx context.Context, params AppRoleListSecretIdsParams) (*StandardListResponse, error)
	// AppRoleLogin invokes app-role-login operation.
	//
	// POST /auth/{approle_mount_path}/login
	AppRoleLogin(ctx context.Context, request *AppRoleLoginRequest, params AppRoleLoginParams) error
	// AppRoleLookUpSecretID invokes app-role-look-up-secret-id operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/secret-id/lookup
	AppRoleLookUpSecretID(ctx context.Context, request *AppRoleLookUpSecretIdRequest, params AppRoleLookUpSecretIDParams) (*AppRoleLookUpSecretIdResponse, error)
	// AppRoleLookUpSecretIDByAccessor invokes app-role-look-up-secret-id-by-accessor operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/lookup
	AppRoleLookUpSecretIDByAccessor(ctx context.Context, request *AppRoleLookUpSecretIdByAccessorRequest, params AppRoleLookUpSecretIDByAccessorParams) (*AppRoleLookUpSecretIdByAccessorResponse, error)
	// AppRoleReadBindSecretID invokes app-role-read-bind-secret-id operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/bind-secret-id
	AppRoleReadBindSecretID(ctx context.Context, params AppRoleReadBindSecretIDParams) (*AppRoleReadBindSecretIdResponse, error)
	// AppRoleReadBoundCidrList invokes app-role-read-bound-cidr-list operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/bound-cidr-list
	AppRoleReadBoundCidrList(ctx context.Context, params AppRoleReadBoundCidrListParams) (*AppRoleReadBoundCidrListResponse, error)
	// AppRoleReadLocalSecretIds invokes app-role-read-local-secret-ids operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/local-secret-ids
	AppRoleReadLocalSecretIds(ctx context.Context, params AppRoleReadLocalSecretIdsParams) (*AppRoleReadLocalSecretIdsResponse, error)
	// AppRoleReadPeriod invokes app-role-read-period operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/period
	AppRoleReadPeriod(ctx context.Context, params AppRoleReadPeriodParams) (*AppRoleReadPeriodResponse, error)
	// AppRoleReadPolicies invokes app-role-read-policies operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/policies
	AppRoleReadPolicies(ctx context.Context, params AppRoleReadPoliciesParams) (*AppRoleReadPoliciesResponse, error)
	// AppRoleReadRole invokes app-role-read-role operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}
	AppRoleReadRole(ctx context.Context, params AppRoleReadRoleParams) (*AppRoleReadRoleResponse, error)
	// AppRoleReadRoleID invokes app-role-read-role-id operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/role-id
	AppRoleReadRoleID(ctx context.Context, params AppRoleReadRoleIDParams) (*AppRoleReadRoleIdResponse, error)
	// AppRoleReadSecretIDBoundCidrs invokes app-role-read-secret-id-bound-cidrs operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs
	AppRoleReadSecretIDBoundCidrs(ctx context.Context, params AppRoleReadSecretIDBoundCidrsParams) (*AppRoleReadSecretIdBoundCidrsResponse, error)
	// AppRoleReadSecretIDNumUses invokes app-role-read-secret-id-num-uses operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses
	AppRoleReadSecretIDNumUses(ctx context.Context, params AppRoleReadSecretIDNumUsesParams) (*AppRoleReadSecretIdNumUsesResponse, error)
	// AppRoleReadSecretIDTTL invokes app-role-read-secret-id-ttl operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/secret-id-ttl
	AppRoleReadSecretIDTTL(ctx context.Context, params AppRoleReadSecretIDTTLParams) (*AppRoleReadSecretIdTtlResponse, error)
	// AppRoleReadTokenBoundCidrs invokes app-role-read-token-bound-cidrs operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs
	AppRoleReadTokenBoundCidrs(ctx context.Context, params AppRoleReadTokenBoundCidrsParams) (*AppRoleReadTokenBoundCidrsResponse, error)
	// AppRoleReadTokenMaxTTL invokes app-role-read-token-max-ttl operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/token-max-ttl
	AppRoleReadTokenMaxTTL(ctx context.Context, params AppRoleReadTokenMaxTTLParams) (*AppRoleReadTokenMaxTtlResponse, error)
	// AppRoleReadTokenNumUses invokes app-role-read-token-num-uses operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/token-num-uses
	AppRoleReadTokenNumUses(ctx context.Context, params AppRoleReadTokenNumUsesParams) (*AppRoleReadTokenNumUsesResponse, error)
	// AppRoleReadTokenTTL invokes app-role-read-token-ttl operation.
	//
	// GET /auth/{approle_mount_path}/role/{role_name}/token-ttl
	AppRoleReadTokenTTL(ctx context.Context, params AppRoleReadTokenTTLParams) (*AppRoleReadTokenTtlResponse, error)
	// AppRoleTidySecretID invokes app-role-tidy-secret-id operation.
	//
	// POST /auth/{approle_mount_path}/tidy/secret-id
	AppRoleTidySecretID(ctx context.Context, params AppRoleTidySecretIDParams) error
	// AppRoleWriteBindSecretID invokes app-role-write-bind-secret-id operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/bind-secret-id
	AppRoleWriteBindSecretID(ctx context.Context, request *AppRoleWriteBindSecretIdRequest, params AppRoleWriteBindSecretIDParams) error
	// AppRoleWriteBoundCidrList invokes app-role-write-bound-cidr-list operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/bound-cidr-list
	AppRoleWriteBoundCidrList(ctx context.Context, request *AppRoleWriteBoundCidrListRequest, params AppRoleWriteBoundCidrListParams) error
	// AppRoleWriteCustomSecretID invokes app-role-write-custom-secret-id operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/custom-secret-id
	AppRoleWriteCustomSecretID(ctx context.Context, request *AppRoleWriteCustomSecretIdRequest, params AppRoleWriteCustomSecretIDParams) (*AppRoleWriteCustomSecretIdResponse, error)
	// AppRoleWritePeriod invokes app-role-write-period operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/period
	AppRoleWritePeriod(ctx context.Context, request *AppRoleWritePeriodRequest, params AppRoleWritePeriodParams) error
	// AppRoleWritePolicies invokes app-role-write-policies operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/policies
	AppRoleWritePolicies(ctx context.Context, request *AppRoleWritePoliciesRequest, params AppRoleWritePoliciesParams) error
	// AppRoleWriteRole invokes app-role-write-role operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}
	AppRoleWriteRole(ctx context.Context, request *AppRoleWriteRoleRequest, params AppRoleWriteRoleParams) error
	// AppRoleWriteRoleID invokes app-role-write-role-id operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/role-id
	AppRoleWriteRoleID(ctx context.Context, request *AppRoleWriteRoleIdRequest, params AppRoleWriteRoleIDParams) error
	// AppRoleWriteSecretID invokes app-role-write-secret-id operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/secret-id
	AppRoleWriteSecretID(ctx context.Context, request *AppRoleWriteSecretIdRequest, params AppRoleWriteSecretIDParams) (*AppRoleWriteSecretIdResponse, error)
	// AppRoleWriteSecretIDBoundCidrs invokes app-role-write-secret-id-bound-cidrs operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs
	AppRoleWriteSecretIDBoundCidrs(ctx context.Context, request *AppRoleWriteSecretIdBoundCidrsRequest, params AppRoleWriteSecretIDBoundCidrsParams) error
	// AppRoleWriteSecretIDNumUses invokes app-role-write-secret-id-num-uses operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses
	AppRoleWriteSecretIDNumUses(ctx context.Context, request *AppRoleWriteSecretIdNumUsesRequest, params AppRoleWriteSecretIDNumUsesParams) error
	// AppRoleWriteSecretIDTTL invokes app-role-write-secret-id-ttl operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-ttl
	AppRoleWriteSecretIDTTL(ctx context.Context, request *AppRoleWriteSecretIdTtlRequest, params AppRoleWriteSecretIDTTLParams) error
	// AppRoleWriteTokenBoundCidrs invokes app-role-write-token-bound-cidrs operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs
	AppRoleWriteTokenBoundCidrs(ctx context.Context, request *AppRoleWriteTokenBoundCidrsRequest, params AppRoleWriteTokenBoundCidrsParams) error
	// AppRoleWriteTokenMaxTTL invokes app-role-write-token-max-ttl operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/token-max-ttl
	AppRoleWriteTokenMaxTTL(ctx context.Context, request *AppRoleWriteTokenMaxTtlRequest, params AppRoleWriteTokenMaxTTLParams) error
	// AppRoleWriteTokenNumUses invokes app-role-write-token-num-uses operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/token-num-uses
	AppRoleWriteTokenNumUses(ctx context.Context, request *AppRoleWriteTokenNumUsesRequest, params AppRoleWriteTokenNumUsesParams) error
	// AppRoleWriteTokenTTL invokes app-role-write-token-ttl operation.
	//
	// POST /auth/{approle_mount_path}/role/{role_name}/token-ttl
	AppRoleWriteTokenTTL(ctx context.Context, request *AppRoleWriteTokenTtlRequest, params AppRoleWriteTokenTTLParams) error
	// KvV2Configure invokes kv-v2-configure operation.
	//
	// Configure backend level settings that are applied to every key in the key-value store.
	//
	// POST /{kv_v2_mount_path}/config
	KvV2Configure(ctx context.Context, request *KvV2ConfigureRequest, params KvV2ConfigureParams) error
	// KvV2Delete invokes kv-v2-delete operation.
	//
	// DELETE /{kv_v2_mount_path}/data/{path}
	KvV2Delete(ctx context.Context, params KvV2DeleteParams) error
	// KvV2DeleteMetadataAndAllVersions invokes kv-v2-delete-metadata-and-all-versions operation.
	//
	// DELETE /{kv_v2_mount_path}/metadata/{path}
	KvV2DeleteMetadataAndAllVersions(ctx context.Context, params KvV2DeleteMetadataAndAllVersionsParams) error
	// KvV2DeleteVersions invokes kv-v2-delete-versions operation.
	//
	// POST /{kv_v2_mount_path}/delete/{path}
	KvV2DeleteVersions(ctx context.Context, request *KvV2DeleteVersionsRequest, params KvV2DeleteVersionsParams) error
	// KvV2DestroyVersions invokes kv-v2-destroy-versions operation.
	//
	// POST /{kv_v2_mount_path}/destroy/{path}
	KvV2DestroyVersions(ctx context.Context, request *KvV2DestroyVersionsRequest, params KvV2DestroyVersionsParams) error
	// KvV2List invokes kv-v2-list operation.
	//
	// GET /{kv_v2_mount_path}/metadata/{path}/
	KvV2List(ctx context.Context, params KvV2ListParams) (*StandardListResponse, error)
	// KvV2Read invokes kv-v2-read operation.
	//
	// GET /{kv_v2_mount_path}/data/{path}
	KvV2Read(ctx context.Context, params KvV2ReadParams) (*KvV2ReadResponse, error)
	// KvV2ReadConfiguration invokes kv-v2-read-configuration operation.
	//
	// Read the backend level settings.
	//
	// GET /{kv_v2_mount_path}/config
	KvV2ReadConfiguration(ctx context.Context, params KvV2ReadConfigurationParams) (*KvV2ReadConfigurationResponse, error)
	// KvV2ReadMetadata invokes kv-v2-read-metadata operation.
	//
	// GET /{kv_v2_mount_path}/metadata/{path}
	KvV2ReadMetadata(ctx context.Context, params KvV2ReadMetadataParams) (*KvV2ReadMetadataResponse, error)
	// KvV2ReadSubkeys invokes kv-v2-read-subkeys operation.
	//
	// GET /{kv_v2_mount_path}/subkeys/{path}
	KvV2ReadSubkeys(ctx context.Context, params KvV2ReadSubkeysParams) (*KvV2ReadSubkeysResponse, error)
	// KvV2UndeleteVersions invokes kv-v2-undelete-versions operation.
	//
	// POST /{kv_v2_mount_path}/undelete/{path}
	KvV2UndeleteVersions(ctx context.Context, request *KvV2UndeleteVersionsRequest, params KvV2UndeleteVersionsParams) error
	// KvV2Write invokes kv-v2-write operation.
	//
	// POST /{kv_v2_mount_path}/data/{path}
	KvV2Write(ctx context.Context, request *KvV2WriteRequest, params KvV2WriteParams) (*KvV2WriteResponse, error)
	// KvV2WriteMetadata invokes kv-v2-write-metadata operation.
	//
	// POST /{kv_v2_mount_path}/metadata/{path}
	KvV2WriteMetadata(ctx context.Context, request *KvV2WriteMetadataRequest, params KvV2WriteMetadataParams) error
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AppRoleDeleteBindSecretID invokes app-role-delete-bind-secret-id operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/bind-secret-id
func (c *Client) AppRoleDeleteBindSecretID(ctx context.Context, params AppRoleDeleteBindSecretIDParams) error {
	_, err := c.sendAppRoleDeleteBindSecretID(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeleteBindSecretID(ctx context.Context, params AppRoleDeleteBindSecretIDParams) (res *AppRoleDeleteBindSecretIDNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-bind-secret-id"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeleteBindSecretID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/bind-secret-id"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeleteBindSecretIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDeleteBoundCidrList invokes app-role-delete-bound-cidr-list operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/bound-cidr-list
func (c *Client) AppRoleDeleteBoundCidrList(ctx context.Context, params AppRoleDeleteBoundCidrListParams) error {
	_, err := c.sendAppRoleDeleteBoundCidrList(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeleteBoundCidrList(ctx context.Context, params AppRoleDeleteBoundCidrListParams) (res *AppRoleDeleteBoundCidrListNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-bound-cidr-list"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeleteBoundCidrList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/bound-cidr-list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeleteBoundCidrListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDeletePeriod invokes app-role-delete-period operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/period
func (c *Client) AppRoleDeletePeriod(ctx context.Context, params AppRoleDeletePeriodParams) error {
	_, err := c.sendAppRoleDeletePeriod(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeletePeriod(ctx context.Context, params AppRoleDeletePeriodParams) (res *AppRoleDeletePeriodNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-period"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/period"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeletePeriod",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/period"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeletePeriodResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDeletePolicies invokes app-role-delete-policies operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/policies
func (c *Client) AppRoleDeletePolicies(ctx context.Context, params AppRoleDeletePoliciesParams) error {
	_, err := c.sendAppRoleDeletePolicies(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeletePolicies(ctx context.Context, params AppRoleDeletePoliciesParams) (res *AppRoleDeletePoliciesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-policies"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/policies"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeletePolicies",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/policies"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeletePoliciesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDeleteRole invokes app-role-delete-role operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}
func (c *Client) AppRoleDeleteRole(ctx context.Context, params AppRoleDeleteRoleParams) error {
	_, err := c.sendAppRoleDeleteRole(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeleteRole(ctx context.Context, params AppRoleDeleteRoleParams) (res *AppRoleDeleteRoleNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-role"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeleteRole",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeleteRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDeleteSecretIDBoundCidrs invokes app-role-delete-secret-id-bound-cidrs operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs
func (c *Client) AppRoleDeleteSecretIDBoundCidrs(ctx context.Context, params AppRoleDeleteSecretIDBoundCidrsParams) error {
	_, err := c.sendAppRoleDeleteSecretIDBoundCidrs(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeleteSecretIDBoundCidrs(ctx context.Context, params AppRoleDeleteSecretIDBoundCidrsParams) (res *AppRoleDeleteSecretIDBoundCidrsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-secret-id-bound-cidrs"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeleteSecretIDBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-bound-cidrs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeleteSecretIDBoundCidrsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDeleteSecretIDNumUses invokes app-role-delete-secret-id-num-uses operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses
func (c *Client) AppRoleDeleteSecretIDNumUses(ctx context.Context, params AppRoleDeleteSecretIDNumUsesParams) error {
	_, err := c.sendAppRoleDeleteSecretIDNumUses(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeleteSecretIDNumUses(ctx context.Context, params AppRoleDeleteSecretIDNumUsesParams) (res *AppRoleDeleteSecretIDNumUsesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-secret-id-num-uses"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeleteSecretIDNumUses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-num-uses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeleteSecretIDNumUsesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDeleteSecretIDTTL invokes app-role-delete-secret-id-ttl operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-ttl
func (c *Client) AppRoleDeleteSecretIDTTL(ctx context.Context, params AppRoleDeleteSecretIDTTLParams) error {
	_, err := c.sendAppRoleDeleteSecretIDTTL(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeleteSecretIDTTL(ctx context.Context, params AppRoleDeleteSecretIDTTLParams) (res *AppRoleDeleteSecretIDTTLNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-secret-id-ttl"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeleteSecretIDTTL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-ttl"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeleteSecretIDTTLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDeleteTokenBoundCidrs invokes app-role-delete-token-bound-cidrs operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs
func (c *Client) AppRoleDeleteTokenBoundCidrs(ctx context.Context, params AppRoleDeleteTokenBoundCidrsParams) error {
	_, err := c.sendAppRoleDeleteTokenBoundCidrs(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeleteTokenBoundCidrs(ctx context.Context, params AppRoleDeleteTokenBoundCidrsParams) (res *AppRoleDeleteTokenBoundCidrsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-token-bound-cidrs"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeleteTokenBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-bound-cidrs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeleteTokenBoundCidrsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDeleteTokenMaxTTL invokes app-role-delete-token-max-ttl operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/token-max-ttl
func (c *Client) AppRoleDeleteTokenMaxTTL(ctx context.Context, params AppRoleDeleteTokenMaxTTLParams) error {
	_, err := c.sendAppRoleDeleteTokenMaxTTL(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeleteTokenMaxTTL(ctx context.Context, params AppRoleDeleteTokenMaxTTLParams) (res *AppRoleDeleteTokenMaxTTLNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-token-max-ttl"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeleteTokenMaxTTL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-max-ttl"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeleteTokenMaxTTLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDeleteTokenNumUses invokes app-role-delete-token-num-uses operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/token-num-uses
func (c *Client) AppRoleDeleteTokenNumUses(ctx context.Context, params AppRoleDeleteTokenNumUsesParams) error {
	_, err := c.sendAppRoleDeleteTokenNumUses(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeleteTokenNumUses(ctx context.Context, params AppRoleDeleteTokenNumUsesParams) (res *AppRoleDeleteTokenNumUsesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-token-num-uses"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-num-uses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeleteTokenNumUses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-num-uses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeleteTokenNumUsesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDeleteTokenTTL invokes app-role-delete-token-ttl operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/token-ttl
func (c *Client) AppRoleDeleteTokenTTL(ctx context.Context, params AppRoleDeleteTokenTTLParams) error {
	_, err := c.sendAppRoleDeleteTokenTTL(ctx, params)
	return err
}

func (c *Client) sendAppRoleDeleteTokenTTL(ctx context.Context, params AppRoleDeleteTokenTTLParams) (res *AppRoleDeleteTokenTTLNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-token-ttl"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-ttl"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDeleteTokenTTL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-ttl"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDeleteTokenTTLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDestroySecretID invokes app-role-destroy-secret-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id/destroy
func (c *Client) AppRoleDestroySecretID(ctx context.Context, request *AppRoleDestroySecretIdRequest, params AppRoleDestroySecretIDParams) error {
	_, err := c.sendAppRoleDestroySecretID(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleDestroySecretID(ctx context.Context, request *AppRoleDestroySecretIdRequest, params AppRoleDestroySecretIDParams) (res *AppRoleDestroySecretIDNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-destroy-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDestroySecretID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id/destroy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleDestroySecretIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDestroySecretIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDestroySecretIDByAccessor invokes app-role-destroy-secret-id-by-accessor operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy
func (c *Client) AppRoleDestroySecretIDByAccessor(ctx context.Context, request *AppRoleDestroySecretIdByAccessorRequest, params AppRoleDestroySecretIDByAccessorParams) error {
	_, err := c.sendAppRoleDestroySecretIDByAccessor(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleDestroySecretIDByAccessor(ctx context.Context, request *AppRoleDestroySecretIdByAccessorRequest, params AppRoleDestroySecretIDByAccessorParams) (res *AppRoleDestroySecretIDByAccessorNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-destroy-secret-id-by-accessor"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDestroySecretIDByAccessor",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-accessor/destroy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleDestroySecretIDByAccessorRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDestroySecretIDByAccessorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDestroySecretIDByAccessor2 invokes app-role-destroy-secret-id-by-accessor2 operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy
func (c *Client) AppRoleDestroySecretIDByAccessor2(ctx context.Context, params AppRoleDestroySecretIDByAccessor2Params) error {
	_, err := c.sendAppRoleDestroySecretIDByAccessor2(ctx, params)
	return err
}

func (c *Client) sendAppRoleDestroySecretIDByAccessor2(ctx context.Context, params AppRoleDestroySecretIDByAccessor2Params) (res *AppRoleDestroySecretIDByAccessor2NoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-destroy-secret-id-by-accessor2"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDestroySecretIDByAccessor2",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-accessor/destroy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "secret_id_accessor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "secret_id_accessor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SecretIDAccessor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDestroySecretIDByAccessor2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleDestroySecretId2 invokes app-role-destroy-secret-id2 operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id/destroy
func (c *Client) AppRoleDestroySecretId2(ctx context.Context, params AppRoleDestroySecretId2Params) error {
	_, err := c.sendAppRoleDestroySecretId2(ctx, params)
	return err
}

func (c *Client) sendAppRoleDestroySecretId2(ctx context.Context, params AppRoleDestroySecretId2Params) (res *AppRoleDestroySecretId2NoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-destroy-secret-id2"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleDestroySecretId2",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id/destroy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "secret_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "secret_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SecretID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleDestroySecretId2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleListRoles invokes app-role-list-roles operation.
//
// GET /auth/{approle_mount_path}/role/
func (c *Client) AppRoleListRoles(ctx context.Context, params AppRoleListRolesParams) (*StandardListResponse, error) {
	res, err := c.sendAppRoleListRoles(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleListRoles(ctx context.Context, params AppRoleListRolesParams) (res *StandardListResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-list-roles"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleListRoles",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "list" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "list",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.List)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleListRolesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleListSecretIds invokes app-role-list-secret-ids operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/secret-id/
func (c *Client) AppRoleListSecretIds(ctx context.Context, params AppRoleListSecretIdsParams) (*StandardListResponse, error) {
	res, err := c.sendAppRoleListSecretIds(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleListSecretIds(ctx context.Context, params AppRoleListSecretIdsParams) (res *StandardListResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-list-secret-ids"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleListSecretIds",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "list" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "list",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.List)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleListSecretIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleLogin invokes app-role-login operation.
//
// POST /auth/{approle_mount_path}/login
func (c *Client) AppRoleLogin(ctx context.Context, request *AppRoleLoginRequest, params AppRoleLoginParams) error {
	_, err := c.sendAppRoleLogin(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleLogin(ctx context.Context, request *AppRoleLoginRequest, params AppRoleLoginParams) (res *AppRoleLoginOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-login"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/login"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleLogin",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/login"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleLoginRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleLoginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleLookUpSecretID invokes app-role-look-up-secret-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id/lookup
func (c *Client) AppRoleLookUpSecretID(ctx context.Context, request *AppRoleLookUpSecretIdRequest, params AppRoleLookUpSecretIDParams) (*AppRoleLookUpSecretIdResponse, error) {
	res, err := c.sendAppRoleLookUpSecretID(ctx, request, params)
	return res, err
}

func (c *Client) sendAppRoleLookUpSecretID(ctx context.Context, request *AppRoleLookUpSecretIdRequest, params AppRoleLookUpSecretIDParams) (res *AppRoleLookUpSecretIdResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-look-up-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id/lookup"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleLookUpSecretID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id/lookup"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleLookUpSecretIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleLookUpSecretIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleLookUpSecretIDByAccessor invokes app-role-look-up-secret-id-by-accessor operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/lookup
func (c *Client) AppRoleLookUpSecretIDByAccessor(ctx context.Context, request *AppRoleLookUpSecretIdByAccessorRequest, params AppRoleLookUpSecretIDByAccessorParams) (*AppRoleLookUpSecretIdByAccessorResponse, error) {
	res, err := c.sendAppRoleLookUpSecretIDByAccessor(ctx, request, params)
	return res, err
}

func (c *Client) sendAppRoleLookUpSecretIDByAccessor(ctx context.Context, request *AppRoleLookUpSecretIdByAccessorRequest, params AppRoleLookUpSecretIDByAccessorParams) (res *AppRoleLookUpSecretIdByAccessorResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-look-up-secret-id-by-accessor"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/lookup"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleLookUpSecretIDByAccessor",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-accessor/lookup"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleLookUpSecretIDByAccessorRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleLookUpSecretIDByAccessorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadBindSecretID invokes app-role-read-bind-secret-id operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/bind-secret-id
func (c *Client) AppRoleReadBindSecretID(ctx context.Context, params AppRoleReadBindSecretIDParams) (*AppRoleReadBindSecretIdResponse, error) {
	res, err := c.sendAppRoleReadBindSecretID(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadBindSecretID(ctx context.Context, params AppRoleReadBindSecretIDParams) (res *AppRoleReadBindSecretIdResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-bind-secret-id"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadBindSecretID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/bind-secret-id"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadBindSecretIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadBoundCidrList invokes app-role-read-bound-cidr-list operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/bound-cidr-list
func (c *Client) AppRoleReadBoundCidrList(ctx context.Context, params AppRoleReadBoundCidrListParams) (*AppRoleReadBoundCidrListResponse, error) {
	res, err := c.sendAppRoleReadBoundCidrList(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadBoundCidrList(ctx context.Context, params AppRoleReadBoundCidrListParams) (res *AppRoleReadBoundCidrListResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-bound-cidr-list"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadBoundCidrList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/bound-cidr-list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadBoundCidrListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadLocalSecretIds invokes app-role-read-local-secret-ids operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/local-secret-ids
func (c *Client) AppRoleReadLocalSecretIds(ctx context.Context, params AppRoleReadLocalSecretIdsParams) (*AppRoleReadLocalSecretIdsResponse, error) {
	res, err := c.sendAppRoleReadLocalSecretIds(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadLocalSecretIds(ctx context.Context, params AppRoleReadLocalSecretIdsParams) (res *AppRoleReadLocalSecretIdsResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-local-secret-ids"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/local-secret-ids"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadLocalSecretIds",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/local-secret-ids"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadLocalSecretIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadPeriod invokes app-role-read-period operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/period
func (c *Client) AppRoleReadPeriod(ctx context.Context, params AppRoleReadPeriodParams) (*AppRoleReadPeriodResponse, error) {
	res, err := c.sendAppRoleReadPeriod(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadPeriod(ctx context.Context, params AppRoleReadPeriodParams) (res *AppRoleReadPeriodResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-period"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/period"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadPeriod",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/period"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadPeriodResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadPolicies invokes app-role-read-policies operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/policies
func (c *Client) AppRoleReadPolicies(ctx context.Context, params AppRoleReadPoliciesParams) (*AppRoleReadPoliciesResponse, error) {
	res, err := c.sendAppRoleReadPolicies(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadPolicies(ctx context.Context, params AppRoleReadPoliciesParams) (res *AppRoleReadPoliciesResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-policies"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/policies"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadPolicies",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/policies"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadPoliciesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadRole invokes app-role-read-role operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}
func (c *Client) AppRoleReadRole(ctx context.Context, params AppRoleReadRoleParams) (*AppRoleReadRoleResponse, error) {
	res, err := c.sendAppRoleReadRole(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadRole(ctx context.Context, params AppRoleReadRoleParams) (res *AppRoleReadRoleResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-role"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadRole",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadRoleID invokes app-role-read-role-id operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/role-id
func (c *Client) AppRoleReadRoleID(ctx context.Context, params AppRoleReadRoleIDParams) (*AppRoleReadRoleIdResponse, error) {
	res, err := c.sendAppRoleReadRoleID(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadRoleID(ctx context.Context, params AppRoleReadRoleIDParams) (res *AppRoleReadRoleIdResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-role-id"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/role-id"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadRoleID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/role-id"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadRoleIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadSecretIDBoundCidrs invokes app-role-read-secret-id-bound-cidrs operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs
func (c *Client) AppRoleReadSecretIDBoundCidrs(ctx context.Context, params AppRoleReadSecretIDBoundCidrsParams) (*AppRoleReadSecretIdBoundCidrsResponse, error) {
	res, err := c.sendAppRoleReadSecretIDBoundCidrs(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadSecretIDBoundCidrs(ctx context.Context, params AppRoleReadSecretIDBoundCidrsParams) (res *AppRoleReadSecretIdBoundCidrsResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-secret-id-bound-cidrs"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadSecretIDBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-bound-cidrs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadSecretIDBoundCidrsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadSecretIDNumUses invokes app-role-read-secret-id-num-uses operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses
func (c *Client) AppRoleReadSecretIDNumUses(ctx context.Context, params AppRoleReadSecretIDNumUsesParams) (*AppRoleReadSecretIdNumUsesResponse, error) {
	res, err := c.sendAppRoleReadSecretIDNumUses(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadSecretIDNumUses(ctx context.Context, params AppRoleReadSecretIDNumUsesParams) (res *AppRoleReadSecretIdNumUsesResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-secret-id-num-uses"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadSecretIDNumUses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-num-uses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadSecretIDNumUsesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadSecretIDTTL invokes app-role-read-secret-id-ttl operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/secret-id-ttl
func (c *Client) AppRoleReadSecretIDTTL(ctx context.Context, params AppRoleReadSecretIDTTLParams) (*AppRoleReadSecretIdTtlResponse, error) {
	res, err := c.sendAppRoleReadSecretIDTTL(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadSecretIDTTL(ctx context.Context, params AppRoleReadSecretIDTTLParams) (res *AppRoleReadSecretIdTtlResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-secret-id-ttl"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadSecretIDTTL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-ttl"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadSecretIDTTLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadTokenBoundCidrs invokes app-role-read-token-bound-cidrs operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs
func (c *Client) AppRoleReadTokenBoundCidrs(ctx context.Context, params AppRoleReadTokenBoundCidrsParams) (*AppRoleReadTokenBoundCidrsResponse, error) {
	res, err := c.sendAppRoleReadTokenBoundCidrs(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadTokenBoundCidrs(ctx context.Context, params AppRoleReadTokenBoundCidrsParams) (res *AppRoleReadTokenBoundCidrsResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-token-bound-cidrs"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadTokenBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-bound-cidrs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadTokenBoundCidrsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadTokenMaxTTL invokes app-role-read-token-max-ttl operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/token-max-ttl
func (c *Client) AppRoleReadTokenMaxTTL(ctx context.Context, params AppRoleReadTokenMaxTTLParams) (*AppRoleReadTokenMaxTtlResponse, error) {
	res, err := c.sendAppRoleReadTokenMaxTTL(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadTokenMaxTTL(ctx context.Context, params AppRoleReadTokenMaxTTLParams) (res *AppRoleReadTokenMaxTtlResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-token-max-ttl"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadTokenMaxTTL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-max-ttl"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadTokenMaxTTLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadTokenNumUses invokes app-role-read-token-num-uses operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/token-num-uses
func (c *Client) AppRoleReadTokenNumUses(ctx context.Context, params AppRoleReadTokenNumUsesParams) (*AppRoleReadTokenNumUsesResponse, error) {
	res, err := c.sendAppRoleReadTokenNumUses(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadTokenNumUses(ctx context.Context, params AppRoleReadTokenNumUsesParams) (res *AppRoleReadTokenNumUsesResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-token-num-uses"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-num-uses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadTokenNumUses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-num-uses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadTokenNumUsesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleReadTokenTTL invokes app-role-read-token-ttl operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/token-ttl
func (c *Client) AppRoleReadTokenTTL(ctx context.Context, params AppRoleReadTokenTTLParams) (*AppRoleReadTokenTtlResponse, error) {
	res, err := c.sendAppRoleReadTokenTTL(ctx, params)
	return res, err
}

func (c *Client) sendAppRoleReadTokenTTL(ctx context.Context, params AppRoleReadTokenTTLParams) (res *AppRoleReadTokenTtlResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-token-ttl"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-ttl"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleReadTokenTTL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-ttl"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleReadTokenTTLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleTidySecretID invokes app-role-tidy-secret-id operation.
//
// POST /auth/{approle_mount_path}/tidy/secret-id
func (c *Client) AppRoleTidySecretID(ctx context.Context, params AppRoleTidySecretIDParams) error {
	_, err := c.sendAppRoleTidySecretID(ctx, params)
	return err
}

func (c *Client) sendAppRoleTidySecretID(ctx context.Context, params AppRoleTidySecretIDParams) (res *AppRoleTidySecretIDAccepted, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-tidy-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/tidy/secret-id"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleTidySecretID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tidy/secret-id"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleTidySecretIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteBindSecretID invokes app-role-write-bind-secret-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/bind-secret-id
func (c *Client) AppRoleWriteBindSecretID(ctx context.Context, request *AppRoleWriteBindSecretIdRequest, params AppRoleWriteBindSecretIDParams) error {
	_, err := c.sendAppRoleWriteBindSecretID(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWriteBindSecretID(ctx context.Context, request *AppRoleWriteBindSecretIdRequest, params AppRoleWriteBindSecretIDParams) (res *AppRoleWriteBindSecretIDNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-bind-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteBindSecretID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/bind-secret-id"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteBindSecretIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteBindSecretIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteBoundCidrList invokes app-role-write-bound-cidr-list operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/bound-cidr-list
func (c *Client) AppRoleWriteBoundCidrList(ctx context.Context, request *AppRoleWriteBoundCidrListRequest, params AppRoleWriteBoundCidrListParams) error {
	_, err := c.sendAppRoleWriteBoundCidrList(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWriteBoundCidrList(ctx context.Context, request *AppRoleWriteBoundCidrListRequest, params AppRoleWriteBoundCidrListParams) (res *AppRoleWriteBoundCidrListNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-bound-cidr-list"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteBoundCidrList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/bound-cidr-list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteBoundCidrListRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteBoundCidrListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteCustomSecretID invokes app-role-write-custom-secret-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/custom-secret-id
func (c *Client) AppRoleWriteCustomSecretID(ctx context.Context, request *AppRoleWriteCustomSecretIdRequest, params AppRoleWriteCustomSecretIDParams) (*AppRoleWriteCustomSecretIdResponse, error) {
	res, err := c.sendAppRoleWriteCustomSecretID(ctx, request, params)
	return res, err
}

func (c *Client) sendAppRoleWriteCustomSecretID(ctx context.Context, request *AppRoleWriteCustomSecretIdRequest, params AppRoleWriteCustomSecretIDParams) (res *AppRoleWriteCustomSecretIdResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-custom-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/custom-secret-id"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteCustomSecretID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/custom-secret-id"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteCustomSecretIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteCustomSecretIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWritePeriod invokes app-role-write-period operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/period
func (c *Client) AppRoleWritePeriod(ctx context.Context, request *AppRoleWritePeriodRequest, params AppRoleWritePeriodParams) error {
	_, err := c.sendAppRoleWritePeriod(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWritePeriod(ctx context.Context, request *AppRoleWritePeriodRequest, params AppRoleWritePeriodParams) (res *AppRoleWritePeriodNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-period"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/period"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWritePeriod",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/period"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWritePeriodRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWritePeriodResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWritePolicies invokes app-role-write-policies operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/policies
func (c *Client) AppRoleWritePolicies(ctx context.Context, request *AppRoleWritePoliciesRequest, params AppRoleWritePoliciesParams) error {
	_, err := c.sendAppRoleWritePolicies(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWritePolicies(ctx context.Context, request *AppRoleWritePoliciesRequest, params AppRoleWritePoliciesParams) (res *AppRoleWritePoliciesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-policies"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/policies"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWritePolicies",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/policies"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWritePoliciesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWritePoliciesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteRole invokes app-role-write-role operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}
func (c *Client) AppRoleWriteRole(ctx context.Context, request *AppRoleWriteRoleRequest, params AppRoleWriteRoleParams) error {
	_, err := c.sendAppRoleWriteRole(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWriteRole(ctx context.Context, request *AppRoleWriteRoleRequest, params AppRoleWriteRoleParams) (res *AppRoleWriteRoleOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-role"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteRole",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteRoleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteRoleID invokes app-role-write-role-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/role-id
func (c *Client) AppRoleWriteRoleID(ctx context.Context, request *AppRoleWriteRoleIdRequest, params AppRoleWriteRoleIDParams) error {
	_, err := c.sendAppRoleWriteRoleID(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWriteRoleID(ctx context.Context, request *AppRoleWriteRoleIdRequest, params AppRoleWriteRoleIDParams) (res *AppRoleWriteRoleIDNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-role-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/role-id"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteRoleID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/role-id"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteRoleIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteRoleIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteSecretID invokes app-role-write-secret-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id
func (c *Client) AppRoleWriteSecretID(ctx context.Context, request *AppRoleWriteSecretIdRequest, params AppRoleWriteSecretIDParams) (*AppRoleWriteSecretIdResponse, error) {
	res, err := c.sendAppRoleWriteSecretID(ctx, request, params)
	return res, err
}

func (c *Client) sendAppRoleWriteSecretID(ctx context.Context, request *AppRoleWriteSecretIdRequest, params AppRoleWriteSecretIDParams) (res *AppRoleWriteSecretIdResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteSecretID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteSecretIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteSecretIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteSecretIDBoundCidrs invokes app-role-write-secret-id-bound-cidrs operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs
func (c *Client) AppRoleWriteSecretIDBoundCidrs(ctx context.Context, request *AppRoleWriteSecretIdBoundCidrsRequest, params AppRoleWriteSecretIDBoundCidrsParams) error {
	_, err := c.sendAppRoleWriteSecretIDBoundCidrs(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWriteSecretIDBoundCidrs(ctx context.Context, request *AppRoleWriteSecretIdBoundCidrsRequest, params AppRoleWriteSecretIDBoundCidrsParams) (res *AppRoleWriteSecretIDBoundCidrsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-secret-id-bound-cidrs"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteSecretIDBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-bound-cidrs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteSecretIDBoundCidrsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteSecretIDBoundCidrsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteSecretIDNumUses invokes app-role-write-secret-id-num-uses operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses
func (c *Client) AppRoleWriteSecretIDNumUses(ctx context.Context, request *AppRoleWriteSecretIdNumUsesRequest, params AppRoleWriteSecretIDNumUsesParams) error {
	_, err := c.sendAppRoleWriteSecretIDNumUses(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWriteSecretIDNumUses(ctx context.Context, request *AppRoleWriteSecretIdNumUsesRequest, params AppRoleWriteSecretIDNumUsesParams) (res *AppRoleWriteSecretIDNumUsesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-secret-id-num-uses"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteSecretIDNumUses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-num-uses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteSecretIDNumUsesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteSecretIDNumUsesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteSecretIDTTL invokes app-role-write-secret-id-ttl operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-ttl
func (c *Client) AppRoleWriteSecretIDTTL(ctx context.Context, request *AppRoleWriteSecretIdTtlRequest, params AppRoleWriteSecretIDTTLParams) error {
	_, err := c.sendAppRoleWriteSecretIDTTL(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWriteSecretIDTTL(ctx context.Context, request *AppRoleWriteSecretIdTtlRequest, params AppRoleWriteSecretIDTTLParams) (res *AppRoleWriteSecretIDTTLNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-secret-id-ttl"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteSecretIDTTL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/secret-id-ttl"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteSecretIDTTLRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteSecretIDTTLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteTokenBoundCidrs invokes app-role-write-token-bound-cidrs operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs
func (c *Client) AppRoleWriteTokenBoundCidrs(ctx context.Context, request *AppRoleWriteTokenBoundCidrsRequest, params AppRoleWriteTokenBoundCidrsParams) error {
	_, err := c.sendAppRoleWriteTokenBoundCidrs(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWriteTokenBoundCidrs(ctx context.Context, request *AppRoleWriteTokenBoundCidrsRequest, params AppRoleWriteTokenBoundCidrsParams) (res *AppRoleWriteTokenBoundCidrsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-token-bound-cidrs"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteTokenBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-bound-cidrs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteTokenBoundCidrsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteTokenBoundCidrsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteTokenMaxTTL invokes app-role-write-token-max-ttl operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/token-max-ttl
func (c *Client) AppRoleWriteTokenMaxTTL(ctx context.Context, request *AppRoleWriteTokenMaxTtlRequest, params AppRoleWriteTokenMaxTTLParams) error {
	_, err := c.sendAppRoleWriteTokenMaxTTL(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWriteTokenMaxTTL(ctx context.Context, request *AppRoleWriteTokenMaxTtlRequest, params AppRoleWriteTokenMaxTTLParams) (res *AppRoleWriteTokenMaxTTLNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-token-max-ttl"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteTokenMaxTTL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-max-ttl"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteTokenMaxTTLRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteTokenMaxTTLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteTokenNumUses invokes app-role-write-token-num-uses operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/token-num-uses
func (c *Client) AppRoleWriteTokenNumUses(ctx context.Context, request *AppRoleWriteTokenNumUsesRequest, params AppRoleWriteTokenNumUsesParams) error {
	_, err := c.sendAppRoleWriteTokenNumUses(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWriteTokenNumUses(ctx context.Context, request *AppRoleWriteTokenNumUsesRequest, params AppRoleWriteTokenNumUsesParams) (res *AppRoleWriteTokenNumUsesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-token-num-uses"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-num-uses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteTokenNumUses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-num-uses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteTokenNumUsesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteTokenNumUsesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AppRoleWriteTokenTTL invokes app-role-write-token-ttl operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/token-ttl
func (c *Client) AppRoleWriteTokenTTL(ctx context.Context, request *AppRoleWriteTokenTtlRequest, params AppRoleWriteTokenTTLParams) error {
	_, err := c.sendAppRoleWriteTokenTTL(ctx, request, params)
	return err
}

func (c *Client) sendAppRoleWriteTokenTTL(ctx context.Context, request *AppRoleWriteTokenTtlRequest, params AppRoleWriteTokenTTLParams) (res *AppRoleWriteTokenTTLNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-token-ttl"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-ttl"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AppRoleWriteTokenTTL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/auth/"
	{
		// Encode "approle_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "approle_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApproleMountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role/"
	{
		// Encode "role_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "role_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/token-ttl"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAppRoleWriteTokenTTLRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAppRoleWriteTokenTTLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2Configure invokes kv-v2-configure operation.
//
// Configure backend level settings that are applied to every key in the key-value store.
//
// POST /{kv_v2_mount_path}/config
func (c *Client) KvV2Configure(ctx context.Context, request *KvV2ConfigureRequest, params KvV2ConfigureParams) error {
	_, err := c.sendKvV2Configure(ctx, request, params)
	return err
}

func (c *Client) sendKvV2Configure(ctx context.Context, request *KvV2ConfigureRequest, params KvV2ConfigureParams) (res *KvV2ConfigureNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-configure"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/config"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2Configure",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeKvV2ConfigureRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2ConfigureResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2Delete invokes kv-v2-delete operation.
//
// DELETE /{kv_v2_mount_path}/data/{path}
func (c *Client) KvV2Delete(ctx context.Context, params KvV2DeleteParams) error {
	_, err := c.sendKvV2Delete(ctx, params)
	return err
}

func (c *Client) sendKvV2Delete(ctx context.Context, params KvV2DeleteParams) (res *KvV2DeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-delete"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/data/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2Delete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/data/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2DeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2DeleteMetadataAndAllVersions invokes kv-v2-delete-metadata-and-all-versions operation.
//
// DELETE /{kv_v2_mount_path}/metadata/{path}
func (c *Client) KvV2DeleteMetadataAndAllVersions(ctx context.Context, params KvV2DeleteMetadataAndAllVersionsParams) error {
	_, err := c.sendKvV2DeleteMetadataAndAllVersions(ctx, params)
	return err
}

func (c *Client) sendKvV2DeleteMetadataAndAllVersions(ctx context.Context, params KvV2DeleteMetadataAndAllVersionsParams) (res *KvV2DeleteMetadataAndAllVersionsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-delete-metadata-and-all-versions"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/metadata/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2DeleteMetadataAndAllVersions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/metadata/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2DeleteMetadataAndAllVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2DeleteVersions invokes kv-v2-delete-versions operation.
//
// POST /{kv_v2_mount_path}/delete/{path}
func (c *Client) KvV2DeleteVersions(ctx context.Context, request *KvV2DeleteVersionsRequest, params KvV2DeleteVersionsParams) error {
	_, err := c.sendKvV2DeleteVersions(ctx, request, params)
	return err
}

func (c *Client) sendKvV2DeleteVersions(ctx context.Context, request *KvV2DeleteVersionsRequest, params KvV2DeleteVersionsParams) (res *KvV2DeleteVersionsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-delete-versions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/delete/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2DeleteVersions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/delete/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeKvV2DeleteVersionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2DeleteVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2DestroyVersions invokes kv-v2-destroy-versions operation.
//
// POST /{kv_v2_mount_path}/destroy/{path}
func (c *Client) KvV2DestroyVersions(ctx context.Context, request *KvV2DestroyVersionsRequest, params KvV2DestroyVersionsParams) error {
	_, err := c.sendKvV2DestroyVersions(ctx, request, params)
	return err
}

func (c *Client) sendKvV2DestroyVersions(ctx context.Context, request *KvV2DestroyVersionsRequest, params KvV2DestroyVersionsParams) (res *KvV2DestroyVersionsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-destroy-versions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/destroy/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2DestroyVersions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/destroy/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeKvV2DestroyVersionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2DestroyVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2List invokes kv-v2-list operation.
//
// GET /{kv_v2_mount_path}/metadata/{path}/
func (c *Client) KvV2List(ctx context.Context, params KvV2ListParams) (*StandardListResponse, error) {
	res, err := c.sendKvV2List(ctx, params)
	return res, err
}

func (c *Client) sendKvV2List(ctx context.Context, params KvV2ListParams) (res *StandardListResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-list"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/metadata/{path}/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2List",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/metadata/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "list" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "list",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.List)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2ListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2Read invokes kv-v2-read operation.
//
// GET /{kv_v2_mount_path}/data/{path}
func (c *Client) KvV2Read(ctx context.Context, params KvV2ReadParams) (*KvV2ReadResponse, error) {
	res, err := c.sendKvV2Read(ctx, params)
	return res, err
}

func (c *Client) sendKvV2Read(ctx context.Context, params KvV2ReadParams) (res *KvV2ReadResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-read"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/data/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2Read",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/data/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2ReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2ReadConfiguration invokes kv-v2-read-configuration operation.
//
// Read the backend level settings.
//
// GET /{kv_v2_mount_path}/config
func (c *Client) KvV2ReadConfiguration(ctx context.Context, params KvV2ReadConfigurationParams) (*KvV2ReadConfigurationResponse, error) {
	res, err := c.sendKvV2ReadConfiguration(ctx, params)
	return res, err
}

func (c *Client) sendKvV2ReadConfiguration(ctx context.Context, params KvV2ReadConfigurationParams) (res *KvV2ReadConfigurationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-read-configuration"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/config"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2ReadConfiguration",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2ReadConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2ReadMetadata invokes kv-v2-read-metadata operation.
//
// GET /{kv_v2_mount_path}/metadata/{path}
func (c *Client) KvV2ReadMetadata(ctx context.Context, params KvV2ReadMetadataParams) (*KvV2ReadMetadataResponse, error) {
	res, err := c.sendKvV2ReadMetadata(ctx, params)
	return res, err
}

func (c *Client) sendKvV2ReadMetadata(ctx context.Context, params KvV2ReadMetadataParams) (res *KvV2ReadMetadataResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-read-metadata"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/metadata/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2ReadMetadata",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/metadata/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2ReadMetadataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2ReadSubkeys invokes kv-v2-read-subkeys operation.
//
// GET /{kv_v2_mount_path}/subkeys/{path}
func (c *Client) KvV2ReadSubkeys(ctx context.Context, params KvV2ReadSubkeysParams) (*KvV2ReadSubkeysResponse, error) {
	res, err := c.sendKvV2ReadSubkeys(ctx, params)
	return res, err
}

func (c *Client) sendKvV2ReadSubkeys(ctx context.Context, params KvV2ReadSubkeysParams) (res *KvV2ReadSubkeysResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-read-subkeys"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/subkeys/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2ReadSubkeys",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subkeys/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2ReadSubkeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2UndeleteVersions invokes kv-v2-undelete-versions operation.
//
// POST /{kv_v2_mount_path}/undelete/{path}
func (c *Client) KvV2UndeleteVersions(ctx context.Context, request *KvV2UndeleteVersionsRequest, params KvV2UndeleteVersionsParams) error {
	_, err := c.sendKvV2UndeleteVersions(ctx, request, params)
	return err
}

func (c *Client) sendKvV2UndeleteVersions(ctx context.Context, request *KvV2UndeleteVersionsRequest, params KvV2UndeleteVersionsParams) (res *KvV2UndeleteVersionsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-undelete-versions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/undelete/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2UndeleteVersions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/undelete/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeKvV2UndeleteVersionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2UndeleteVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2Write invokes kv-v2-write operation.
//
// POST /{kv_v2_mount_path}/data/{path}
func (c *Client) KvV2Write(ctx context.Context, request *KvV2WriteRequest, params KvV2WriteParams) (*KvV2WriteResponse, error) {
	res, err := c.sendKvV2Write(ctx, request, params)
	return res, err
}

func (c *Client) sendKvV2Write(ctx context.Context, request *KvV2WriteRequest, params KvV2WriteParams) (res *KvV2WriteResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-write"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/data/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2Write",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/data/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeKvV2WriteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2WriteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KvV2WriteMetadata invokes kv-v2-write-metadata operation.
//
// POST /{kv_v2_mount_path}/metadata/{path}
func (c *Client) KvV2WriteMetadata(ctx context.Context, request *KvV2WriteMetadataRequest, params KvV2WriteMetadataParams) error {
	_, err := c.sendKvV2WriteMetadata(ctx, request, params)
	return err
}

func (c *Client) sendKvV2WriteMetadata(ctx context.Context, request *KvV2WriteMetadataRequest, params KvV2WriteMetadataParams) (res *KvV2WriteMetadataNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-write-metadata"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/metadata/{path}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "KvV2WriteMetadata",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/"
	{
		// Encode "kv_v2_mount_path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kv_v2_mount_path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.KvV2MountPath))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/metadata/"
	{
		// Encode "path" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "path",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeKvV2WriteMetadataRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeKvV2WriteMetadataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
