// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
)

// handleAppRoleDeleteBindSecretIDRequest handles app-role-delete-bind-secret-id operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/bind-secret-id
func (s *Server) handleAppRoleDeleteBindSecretIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-bind-secret-id"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeleteBindSecretID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeleteBindSecretID",
			ID:   "app-role-delete-bind-secret-id",
		}
	)
	params, err := decodeAppRoleDeleteBindSecretIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeleteBindSecretIDNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeleteBindSecretID",
			OperationSummary: "",
			OperationID:      "app-role-delete-bind-secret-id",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeleteBindSecretIDParams
			Response = *AppRoleDeleteBindSecretIDNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeleteBindSecretIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeleteBindSecretID(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeleteBindSecretID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeleteBindSecretIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDeleteBoundCidrListRequest handles app-role-delete-bound-cidr-list operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/bound-cidr-list
func (s *Server) handleAppRoleDeleteBoundCidrListRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-bound-cidr-list"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeleteBoundCidrList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeleteBoundCidrList",
			ID:   "app-role-delete-bound-cidr-list",
		}
	)
	params, err := decodeAppRoleDeleteBoundCidrListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeleteBoundCidrListNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeleteBoundCidrList",
			OperationSummary: "",
			OperationID:      "app-role-delete-bound-cidr-list",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeleteBoundCidrListParams
			Response = *AppRoleDeleteBoundCidrListNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeleteBoundCidrListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeleteBoundCidrList(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeleteBoundCidrList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeleteBoundCidrListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDeletePeriodRequest handles app-role-delete-period operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/period
func (s *Server) handleAppRoleDeletePeriodRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-period"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/period"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeletePeriod",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeletePeriod",
			ID:   "app-role-delete-period",
		}
	)
	params, err := decodeAppRoleDeletePeriodParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeletePeriodNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeletePeriod",
			OperationSummary: "",
			OperationID:      "app-role-delete-period",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeletePeriodParams
			Response = *AppRoleDeletePeriodNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeletePeriodParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeletePeriod(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeletePeriod(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeletePeriodResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDeletePoliciesRequest handles app-role-delete-policies operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/policies
func (s *Server) handleAppRoleDeletePoliciesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-policies"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/policies"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeletePolicies",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeletePolicies",
			ID:   "app-role-delete-policies",
		}
	)
	params, err := decodeAppRoleDeletePoliciesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeletePoliciesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeletePolicies",
			OperationSummary: "",
			OperationID:      "app-role-delete-policies",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeletePoliciesParams
			Response = *AppRoleDeletePoliciesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeletePoliciesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeletePolicies(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeletePolicies(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeletePoliciesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDeleteRoleRequest handles app-role-delete-role operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}
func (s *Server) handleAppRoleDeleteRoleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-role"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeleteRole",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeleteRole",
			ID:   "app-role-delete-role",
		}
	)
	params, err := decodeAppRoleDeleteRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeleteRoleNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeleteRole",
			OperationSummary: "",
			OperationID:      "app-role-delete-role",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeleteRoleParams
			Response = *AppRoleDeleteRoleNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeleteRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeleteRole(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeleteRole(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeleteRoleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDeleteSecretIDBoundCidrsRequest handles app-role-delete-secret-id-bound-cidrs operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs
func (s *Server) handleAppRoleDeleteSecretIDBoundCidrsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-secret-id-bound-cidrs"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeleteSecretIDBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeleteSecretIDBoundCidrs",
			ID:   "app-role-delete-secret-id-bound-cidrs",
		}
	)
	params, err := decodeAppRoleDeleteSecretIDBoundCidrsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeleteSecretIDBoundCidrsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeleteSecretIDBoundCidrs",
			OperationSummary: "",
			OperationID:      "app-role-delete-secret-id-bound-cidrs",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeleteSecretIDBoundCidrsParams
			Response = *AppRoleDeleteSecretIDBoundCidrsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeleteSecretIDBoundCidrsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeleteSecretIDBoundCidrs(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeleteSecretIDBoundCidrs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeleteSecretIDBoundCidrsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDeleteSecretIDNumUsesRequest handles app-role-delete-secret-id-num-uses operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses
func (s *Server) handleAppRoleDeleteSecretIDNumUsesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-secret-id-num-uses"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeleteSecretIDNumUses",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeleteSecretIDNumUses",
			ID:   "app-role-delete-secret-id-num-uses",
		}
	)
	params, err := decodeAppRoleDeleteSecretIDNumUsesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeleteSecretIDNumUsesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeleteSecretIDNumUses",
			OperationSummary: "",
			OperationID:      "app-role-delete-secret-id-num-uses",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeleteSecretIDNumUsesParams
			Response = *AppRoleDeleteSecretIDNumUsesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeleteSecretIDNumUsesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeleteSecretIDNumUses(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeleteSecretIDNumUses(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeleteSecretIDNumUsesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDeleteSecretIDTTLRequest handles app-role-delete-secret-id-ttl operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-ttl
func (s *Server) handleAppRoleDeleteSecretIDTTLRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-secret-id-ttl"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeleteSecretIDTTL",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeleteSecretIDTTL",
			ID:   "app-role-delete-secret-id-ttl",
		}
	)
	params, err := decodeAppRoleDeleteSecretIDTTLParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeleteSecretIDTTLNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeleteSecretIDTTL",
			OperationSummary: "",
			OperationID:      "app-role-delete-secret-id-ttl",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeleteSecretIDTTLParams
			Response = *AppRoleDeleteSecretIDTTLNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeleteSecretIDTTLParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeleteSecretIDTTL(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeleteSecretIDTTL(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeleteSecretIDTTLResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDeleteTokenBoundCidrsRequest handles app-role-delete-token-bound-cidrs operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs
func (s *Server) handleAppRoleDeleteTokenBoundCidrsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-token-bound-cidrs"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeleteTokenBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeleteTokenBoundCidrs",
			ID:   "app-role-delete-token-bound-cidrs",
		}
	)
	params, err := decodeAppRoleDeleteTokenBoundCidrsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeleteTokenBoundCidrsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeleteTokenBoundCidrs",
			OperationSummary: "",
			OperationID:      "app-role-delete-token-bound-cidrs",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeleteTokenBoundCidrsParams
			Response = *AppRoleDeleteTokenBoundCidrsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeleteTokenBoundCidrsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeleteTokenBoundCidrs(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeleteTokenBoundCidrs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeleteTokenBoundCidrsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDeleteTokenMaxTTLRequest handles app-role-delete-token-max-ttl operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/token-max-ttl
func (s *Server) handleAppRoleDeleteTokenMaxTTLRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-token-max-ttl"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeleteTokenMaxTTL",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeleteTokenMaxTTL",
			ID:   "app-role-delete-token-max-ttl",
		}
	)
	params, err := decodeAppRoleDeleteTokenMaxTTLParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeleteTokenMaxTTLNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeleteTokenMaxTTL",
			OperationSummary: "",
			OperationID:      "app-role-delete-token-max-ttl",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeleteTokenMaxTTLParams
			Response = *AppRoleDeleteTokenMaxTTLNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeleteTokenMaxTTLParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeleteTokenMaxTTL(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeleteTokenMaxTTL(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeleteTokenMaxTTLResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDeleteTokenNumUsesRequest handles app-role-delete-token-num-uses operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/token-num-uses
func (s *Server) handleAppRoleDeleteTokenNumUsesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-token-num-uses"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-num-uses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeleteTokenNumUses",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeleteTokenNumUses",
			ID:   "app-role-delete-token-num-uses",
		}
	)
	params, err := decodeAppRoleDeleteTokenNumUsesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeleteTokenNumUsesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeleteTokenNumUses",
			OperationSummary: "",
			OperationID:      "app-role-delete-token-num-uses",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeleteTokenNumUsesParams
			Response = *AppRoleDeleteTokenNumUsesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeleteTokenNumUsesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeleteTokenNumUses(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeleteTokenNumUses(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeleteTokenNumUsesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDeleteTokenTTLRequest handles app-role-delete-token-ttl operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/token-ttl
func (s *Server) handleAppRoleDeleteTokenTTLRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-delete-token-ttl"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-ttl"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDeleteTokenTTL",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDeleteTokenTTL",
			ID:   "app-role-delete-token-ttl",
		}
	)
	params, err := decodeAppRoleDeleteTokenTTLParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDeleteTokenTTLNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDeleteTokenTTL",
			OperationSummary: "",
			OperationID:      "app-role-delete-token-ttl",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDeleteTokenTTLParams
			Response = *AppRoleDeleteTokenTTLNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDeleteTokenTTLParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDeleteTokenTTL(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDeleteTokenTTL(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDeleteTokenTTLResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDestroySecretIDRequest handles app-role-destroy-secret-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id/destroy
func (s *Server) handleAppRoleDestroySecretIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-destroy-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDestroySecretID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDestroySecretID",
			ID:   "app-role-destroy-secret-id",
		}
	)
	params, err := decodeAppRoleDestroySecretIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleDestroySecretIDRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleDestroySecretIDNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDestroySecretID",
			OperationSummary: "",
			OperationID:      "app-role-destroy-secret-id",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleDestroySecretIdRequest
			Params   = AppRoleDestroySecretIDParams
			Response = *AppRoleDestroySecretIDNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDestroySecretIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDestroySecretID(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDestroySecretID(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDestroySecretIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDestroySecretIDByAccessorRequest handles app-role-destroy-secret-id-by-accessor operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy
func (s *Server) handleAppRoleDestroySecretIDByAccessorRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-destroy-secret-id-by-accessor"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDestroySecretIDByAccessor",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDestroySecretIDByAccessor",
			ID:   "app-role-destroy-secret-id-by-accessor",
		}
	)
	params, err := decodeAppRoleDestroySecretIDByAccessorParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleDestroySecretIDByAccessorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleDestroySecretIDByAccessorNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDestroySecretIDByAccessor",
			OperationSummary: "",
			OperationID:      "app-role-destroy-secret-id-by-accessor",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleDestroySecretIdByAccessorRequest
			Params   = AppRoleDestroySecretIDByAccessorParams
			Response = *AppRoleDestroySecretIDByAccessorNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDestroySecretIDByAccessorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDestroySecretIDByAccessor(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDestroySecretIDByAccessor(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDestroySecretIDByAccessorResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDestroySecretIDByAccessor2Request handles app-role-destroy-secret-id-by-accessor2 operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy
func (s *Server) handleAppRoleDestroySecretIDByAccessor2Request(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-destroy-secret-id-by-accessor2"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDestroySecretIDByAccessor2",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDestroySecretIDByAccessor2",
			ID:   "app-role-destroy-secret-id-by-accessor2",
		}
	)
	params, err := decodeAppRoleDestroySecretIDByAccessor2Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDestroySecretIDByAccessor2NoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDestroySecretIDByAccessor2",
			OperationSummary: "",
			OperationID:      "app-role-destroy-secret-id-by-accessor2",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "secret_id_accessor",
					In:   "query",
				}: params.SecretIDAccessor,
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDestroySecretIDByAccessor2Params
			Response = *AppRoleDestroySecretIDByAccessor2NoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDestroySecretIDByAccessor2Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDestroySecretIDByAccessor2(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDestroySecretIDByAccessor2(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDestroySecretIDByAccessor2Response(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleDestroySecretId2Request handles app-role-destroy-secret-id2 operation.
//
// DELETE /auth/{approle_mount_path}/role/{role_name}/secret-id/destroy
func (s *Server) handleAppRoleDestroySecretId2Request(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-destroy-secret-id2"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleDestroySecretId2",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleDestroySecretId2",
			ID:   "app-role-destroy-secret-id2",
		}
	)
	params, err := decodeAppRoleDestroySecretId2Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleDestroySecretId2NoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleDestroySecretId2",
			OperationSummary: "",
			OperationID:      "app-role-destroy-secret-id2",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "secret_id",
					In:   "query",
				}: params.SecretID,
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleDestroySecretId2Params
			Response = *AppRoleDestroySecretId2NoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleDestroySecretId2Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleDestroySecretId2(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleDestroySecretId2(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleDestroySecretId2Response(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleListRolesRequest handles app-role-list-roles operation.
//
// GET /auth/{approle_mount_path}/role/
func (s *Server) handleAppRoleListRolesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-list-roles"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleListRoles",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleListRoles",
			ID:   "app-role-list-roles",
		}
	)
	params, err := decodeAppRoleListRolesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *StandardListResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleListRoles",
			OperationSummary: "",
			OperationID:      "app-role-list-roles",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "list",
					In:   "query",
				}: params.List,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleListRolesParams
			Response = *StandardListResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleListRolesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleListRoles(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleListRoles(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleListRolesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleListSecretIdsRequest handles app-role-list-secret-ids operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/secret-id/
func (s *Server) handleAppRoleListSecretIdsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-list-secret-ids"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleListSecretIds",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleListSecretIds",
			ID:   "app-role-list-secret-ids",
		}
	)
	params, err := decodeAppRoleListSecretIdsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *StandardListResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleListSecretIds",
			OperationSummary: "",
			OperationID:      "app-role-list-secret-ids",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "list",
					In:   "query",
				}: params.List,
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleListSecretIdsParams
			Response = *StandardListResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleListSecretIdsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleListSecretIds(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleListSecretIds(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleListSecretIdsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleLoginRequest handles app-role-login operation.
//
// POST /auth/{approle_mount_path}/login
func (s *Server) handleAppRoleLoginRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-login"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/login"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleLogin",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleLogin",
			ID:   "app-role-login",
		}
	)
	params, err := decodeAppRoleLoginParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleLoginRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleLoginOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleLogin",
			OperationSummary: "",
			OperationID:      "app-role-login",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleLoginRequest
			Params   = AppRoleLoginParams
			Response = *AppRoleLoginOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleLoginParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleLogin(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleLogin(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleLoginResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleLookUpSecretIDRequest handles app-role-look-up-secret-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id/lookup
func (s *Server) handleAppRoleLookUpSecretIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-look-up-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id/lookup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleLookUpSecretID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleLookUpSecretID",
			ID:   "app-role-look-up-secret-id",
		}
	)
	params, err := decodeAppRoleLookUpSecretIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleLookUpSecretIDRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleLookUpSecretIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleLookUpSecretID",
			OperationSummary: "",
			OperationID:      "app-role-look-up-secret-id",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleLookUpSecretIdRequest
			Params   = AppRoleLookUpSecretIDParams
			Response = *AppRoleLookUpSecretIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleLookUpSecretIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleLookUpSecretID(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleLookUpSecretID(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleLookUpSecretIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleLookUpSecretIDByAccessorRequest handles app-role-look-up-secret-id-by-accessor operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/lookup
func (s *Server) handleAppRoleLookUpSecretIDByAccessorRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-look-up-secret-id-by-accessor"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/lookup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleLookUpSecretIDByAccessor",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleLookUpSecretIDByAccessor",
			ID:   "app-role-look-up-secret-id-by-accessor",
		}
	)
	params, err := decodeAppRoleLookUpSecretIDByAccessorParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleLookUpSecretIDByAccessorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleLookUpSecretIdByAccessorResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleLookUpSecretIDByAccessor",
			OperationSummary: "",
			OperationID:      "app-role-look-up-secret-id-by-accessor",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleLookUpSecretIdByAccessorRequest
			Params   = AppRoleLookUpSecretIDByAccessorParams
			Response = *AppRoleLookUpSecretIdByAccessorResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleLookUpSecretIDByAccessorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleLookUpSecretIDByAccessor(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleLookUpSecretIDByAccessor(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleLookUpSecretIDByAccessorResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadBindSecretIDRequest handles app-role-read-bind-secret-id operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/bind-secret-id
func (s *Server) handleAppRoleReadBindSecretIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-bind-secret-id"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadBindSecretID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadBindSecretID",
			ID:   "app-role-read-bind-secret-id",
		}
	)
	params, err := decodeAppRoleReadBindSecretIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadBindSecretIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadBindSecretID",
			OperationSummary: "",
			OperationID:      "app-role-read-bind-secret-id",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadBindSecretIDParams
			Response = *AppRoleReadBindSecretIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadBindSecretIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadBindSecretID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadBindSecretID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadBindSecretIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadBoundCidrListRequest handles app-role-read-bound-cidr-list operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/bound-cidr-list
func (s *Server) handleAppRoleReadBoundCidrListRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-bound-cidr-list"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadBoundCidrList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadBoundCidrList",
			ID:   "app-role-read-bound-cidr-list",
		}
	)
	params, err := decodeAppRoleReadBoundCidrListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadBoundCidrListResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadBoundCidrList",
			OperationSummary: "",
			OperationID:      "app-role-read-bound-cidr-list",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadBoundCidrListParams
			Response = *AppRoleReadBoundCidrListResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadBoundCidrListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadBoundCidrList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadBoundCidrList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadBoundCidrListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadLocalSecretIdsRequest handles app-role-read-local-secret-ids operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/local-secret-ids
func (s *Server) handleAppRoleReadLocalSecretIdsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-local-secret-ids"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/local-secret-ids"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadLocalSecretIds",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadLocalSecretIds",
			ID:   "app-role-read-local-secret-ids",
		}
	)
	params, err := decodeAppRoleReadLocalSecretIdsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadLocalSecretIdsResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadLocalSecretIds",
			OperationSummary: "",
			OperationID:      "app-role-read-local-secret-ids",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadLocalSecretIdsParams
			Response = *AppRoleReadLocalSecretIdsResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadLocalSecretIdsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadLocalSecretIds(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadLocalSecretIds(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadLocalSecretIdsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadPeriodRequest handles app-role-read-period operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/period
func (s *Server) handleAppRoleReadPeriodRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-period"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/period"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadPeriod",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadPeriod",
			ID:   "app-role-read-period",
		}
	)
	params, err := decodeAppRoleReadPeriodParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadPeriodResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadPeriod",
			OperationSummary: "",
			OperationID:      "app-role-read-period",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadPeriodParams
			Response = *AppRoleReadPeriodResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadPeriodParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadPeriod(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadPeriod(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadPeriodResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadPoliciesRequest handles app-role-read-policies operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/policies
func (s *Server) handleAppRoleReadPoliciesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-policies"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/policies"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadPolicies",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadPolicies",
			ID:   "app-role-read-policies",
		}
	)
	params, err := decodeAppRoleReadPoliciesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadPoliciesResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadPolicies",
			OperationSummary: "",
			OperationID:      "app-role-read-policies",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadPoliciesParams
			Response = *AppRoleReadPoliciesResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadPoliciesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadPolicies(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadPolicies(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadPoliciesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadRoleRequest handles app-role-read-role operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}
func (s *Server) handleAppRoleReadRoleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-role"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadRole",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadRole",
			ID:   "app-role-read-role",
		}
	)
	params, err := decodeAppRoleReadRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadRoleResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadRole",
			OperationSummary: "",
			OperationID:      "app-role-read-role",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadRoleParams
			Response = *AppRoleReadRoleResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadRole(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadRole(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadRoleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadRoleIDRequest handles app-role-read-role-id operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/role-id
func (s *Server) handleAppRoleReadRoleIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-role-id"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/role-id"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadRoleID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadRoleID",
			ID:   "app-role-read-role-id",
		}
	)
	params, err := decodeAppRoleReadRoleIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadRoleIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadRoleID",
			OperationSummary: "",
			OperationID:      "app-role-read-role-id",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadRoleIDParams
			Response = *AppRoleReadRoleIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadRoleIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadRoleID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadRoleID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadRoleIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadSecretIDBoundCidrsRequest handles app-role-read-secret-id-bound-cidrs operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs
func (s *Server) handleAppRoleReadSecretIDBoundCidrsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-secret-id-bound-cidrs"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadSecretIDBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadSecretIDBoundCidrs",
			ID:   "app-role-read-secret-id-bound-cidrs",
		}
	)
	params, err := decodeAppRoleReadSecretIDBoundCidrsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadSecretIdBoundCidrsResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadSecretIDBoundCidrs",
			OperationSummary: "",
			OperationID:      "app-role-read-secret-id-bound-cidrs",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadSecretIDBoundCidrsParams
			Response = *AppRoleReadSecretIdBoundCidrsResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadSecretIDBoundCidrsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadSecretIDBoundCidrs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadSecretIDBoundCidrs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadSecretIDBoundCidrsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadSecretIDNumUsesRequest handles app-role-read-secret-id-num-uses operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses
func (s *Server) handleAppRoleReadSecretIDNumUsesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-secret-id-num-uses"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadSecretIDNumUses",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadSecretIDNumUses",
			ID:   "app-role-read-secret-id-num-uses",
		}
	)
	params, err := decodeAppRoleReadSecretIDNumUsesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadSecretIdNumUsesResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadSecretIDNumUses",
			OperationSummary: "",
			OperationID:      "app-role-read-secret-id-num-uses",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadSecretIDNumUsesParams
			Response = *AppRoleReadSecretIdNumUsesResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadSecretIDNumUsesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadSecretIDNumUses(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadSecretIDNumUses(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadSecretIDNumUsesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadSecretIDTTLRequest handles app-role-read-secret-id-ttl operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/secret-id-ttl
func (s *Server) handleAppRoleReadSecretIDTTLRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-secret-id-ttl"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadSecretIDTTL",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadSecretIDTTL",
			ID:   "app-role-read-secret-id-ttl",
		}
	)
	params, err := decodeAppRoleReadSecretIDTTLParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadSecretIdTtlResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadSecretIDTTL",
			OperationSummary: "",
			OperationID:      "app-role-read-secret-id-ttl",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadSecretIDTTLParams
			Response = *AppRoleReadSecretIdTtlResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadSecretIDTTLParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadSecretIDTTL(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadSecretIDTTL(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadSecretIDTTLResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadTokenBoundCidrsRequest handles app-role-read-token-bound-cidrs operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs
func (s *Server) handleAppRoleReadTokenBoundCidrsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-token-bound-cidrs"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadTokenBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadTokenBoundCidrs",
			ID:   "app-role-read-token-bound-cidrs",
		}
	)
	params, err := decodeAppRoleReadTokenBoundCidrsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadTokenBoundCidrsResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadTokenBoundCidrs",
			OperationSummary: "",
			OperationID:      "app-role-read-token-bound-cidrs",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadTokenBoundCidrsParams
			Response = *AppRoleReadTokenBoundCidrsResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadTokenBoundCidrsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadTokenBoundCidrs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadTokenBoundCidrs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadTokenBoundCidrsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadTokenMaxTTLRequest handles app-role-read-token-max-ttl operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/token-max-ttl
func (s *Server) handleAppRoleReadTokenMaxTTLRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-token-max-ttl"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadTokenMaxTTL",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadTokenMaxTTL",
			ID:   "app-role-read-token-max-ttl",
		}
	)
	params, err := decodeAppRoleReadTokenMaxTTLParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadTokenMaxTtlResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadTokenMaxTTL",
			OperationSummary: "",
			OperationID:      "app-role-read-token-max-ttl",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadTokenMaxTTLParams
			Response = *AppRoleReadTokenMaxTtlResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadTokenMaxTTLParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadTokenMaxTTL(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadTokenMaxTTL(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadTokenMaxTTLResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadTokenNumUsesRequest handles app-role-read-token-num-uses operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/token-num-uses
func (s *Server) handleAppRoleReadTokenNumUsesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-token-num-uses"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-num-uses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadTokenNumUses",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadTokenNumUses",
			ID:   "app-role-read-token-num-uses",
		}
	)
	params, err := decodeAppRoleReadTokenNumUsesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadTokenNumUsesResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadTokenNumUses",
			OperationSummary: "",
			OperationID:      "app-role-read-token-num-uses",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadTokenNumUsesParams
			Response = *AppRoleReadTokenNumUsesResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadTokenNumUsesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadTokenNumUses(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadTokenNumUses(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadTokenNumUsesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleReadTokenTTLRequest handles app-role-read-token-ttl operation.
//
// GET /auth/{approle_mount_path}/role/{role_name}/token-ttl
func (s *Server) handleAppRoleReadTokenTTLRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-read-token-ttl"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-ttl"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleReadTokenTTL",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleReadTokenTTL",
			ID:   "app-role-read-token-ttl",
		}
	)
	params, err := decodeAppRoleReadTokenTTLParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleReadTokenTtlResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleReadTokenTTL",
			OperationSummary: "",
			OperationID:      "app-role-read-token-ttl",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleReadTokenTTLParams
			Response = *AppRoleReadTokenTtlResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleReadTokenTTLParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleReadTokenTTL(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleReadTokenTTL(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleReadTokenTTLResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleTidySecretIDRequest handles app-role-tidy-secret-id operation.
//
// POST /auth/{approle_mount_path}/tidy/secret-id
func (s *Server) handleAppRoleTidySecretIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-tidy-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/tidy/secret-id"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleTidySecretID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleTidySecretID",
			ID:   "app-role-tidy-secret-id",
		}
	)
	params, err := decodeAppRoleTidySecretIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AppRoleTidySecretIDAccepted
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleTidySecretID",
			OperationSummary: "",
			OperationID:      "app-role-tidy-secret-id",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppRoleTidySecretIDParams
			Response = *AppRoleTidySecretIDAccepted
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleTidySecretIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleTidySecretID(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleTidySecretID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleTidySecretIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteBindSecretIDRequest handles app-role-write-bind-secret-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/bind-secret-id
func (s *Server) handleAppRoleWriteBindSecretIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-bind-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteBindSecretID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteBindSecretID",
			ID:   "app-role-write-bind-secret-id",
		}
	)
	params, err := decodeAppRoleWriteBindSecretIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteBindSecretIDRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteBindSecretIDNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteBindSecretID",
			OperationSummary: "",
			OperationID:      "app-role-write-bind-secret-id",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteBindSecretIdRequest
			Params   = AppRoleWriteBindSecretIDParams
			Response = *AppRoleWriteBindSecretIDNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteBindSecretIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWriteBindSecretID(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWriteBindSecretID(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteBindSecretIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteBoundCidrListRequest handles app-role-write-bound-cidr-list operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/bound-cidr-list
func (s *Server) handleAppRoleWriteBoundCidrListRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-bound-cidr-list"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteBoundCidrList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteBoundCidrList",
			ID:   "app-role-write-bound-cidr-list",
		}
	)
	params, err := decodeAppRoleWriteBoundCidrListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteBoundCidrListRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteBoundCidrListNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteBoundCidrList",
			OperationSummary: "",
			OperationID:      "app-role-write-bound-cidr-list",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteBoundCidrListRequest
			Params   = AppRoleWriteBoundCidrListParams
			Response = *AppRoleWriteBoundCidrListNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteBoundCidrListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWriteBoundCidrList(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWriteBoundCidrList(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteBoundCidrListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteCustomSecretIDRequest handles app-role-write-custom-secret-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/custom-secret-id
func (s *Server) handleAppRoleWriteCustomSecretIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-custom-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/custom-secret-id"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteCustomSecretID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteCustomSecretID",
			ID:   "app-role-write-custom-secret-id",
		}
	)
	params, err := decodeAppRoleWriteCustomSecretIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteCustomSecretIDRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteCustomSecretIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteCustomSecretID",
			OperationSummary: "",
			OperationID:      "app-role-write-custom-secret-id",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteCustomSecretIdRequest
			Params   = AppRoleWriteCustomSecretIDParams
			Response = *AppRoleWriteCustomSecretIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteCustomSecretIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleWriteCustomSecretID(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleWriteCustomSecretID(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteCustomSecretIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWritePeriodRequest handles app-role-write-period operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/period
func (s *Server) handleAppRoleWritePeriodRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-period"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/period"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWritePeriod",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWritePeriod",
			ID:   "app-role-write-period",
		}
	)
	params, err := decodeAppRoleWritePeriodParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWritePeriodRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWritePeriodNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWritePeriod",
			OperationSummary: "",
			OperationID:      "app-role-write-period",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWritePeriodRequest
			Params   = AppRoleWritePeriodParams
			Response = *AppRoleWritePeriodNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWritePeriodParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWritePeriod(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWritePeriod(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWritePeriodResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWritePoliciesRequest handles app-role-write-policies operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/policies
func (s *Server) handleAppRoleWritePoliciesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-policies"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/policies"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWritePolicies",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWritePolicies",
			ID:   "app-role-write-policies",
		}
	)
	params, err := decodeAppRoleWritePoliciesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWritePoliciesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWritePoliciesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWritePolicies",
			OperationSummary: "",
			OperationID:      "app-role-write-policies",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWritePoliciesRequest
			Params   = AppRoleWritePoliciesParams
			Response = *AppRoleWritePoliciesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWritePoliciesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWritePolicies(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWritePolicies(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWritePoliciesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteRoleRequest handles app-role-write-role operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}
func (s *Server) handleAppRoleWriteRoleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-role"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteRole",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteRole",
			ID:   "app-role-write-role",
		}
	)
	params, err := decodeAppRoleWriteRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteRoleRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteRoleOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteRole",
			OperationSummary: "",
			OperationID:      "app-role-write-role",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteRoleRequest
			Params   = AppRoleWriteRoleParams
			Response = *AppRoleWriteRoleOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWriteRole(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWriteRole(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteRoleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteRoleIDRequest handles app-role-write-role-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/role-id
func (s *Server) handleAppRoleWriteRoleIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-role-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/role-id"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteRoleID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteRoleID",
			ID:   "app-role-write-role-id",
		}
	)
	params, err := decodeAppRoleWriteRoleIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteRoleIDRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteRoleIDNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteRoleID",
			OperationSummary: "",
			OperationID:      "app-role-write-role-id",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteRoleIdRequest
			Params   = AppRoleWriteRoleIDParams
			Response = *AppRoleWriteRoleIDNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteRoleIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWriteRoleID(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWriteRoleID(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteRoleIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteSecretIDRequest handles app-role-write-secret-id operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id
func (s *Server) handleAppRoleWriteSecretIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-secret-id"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteSecretID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteSecretID",
			ID:   "app-role-write-secret-id",
		}
	)
	params, err := decodeAppRoleWriteSecretIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteSecretIDRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteSecretIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteSecretID",
			OperationSummary: "",
			OperationID:      "app-role-write-secret-id",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteSecretIdRequest
			Params   = AppRoleWriteSecretIDParams
			Response = *AppRoleWriteSecretIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteSecretIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppRoleWriteSecretID(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppRoleWriteSecretID(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteSecretIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteSecretIDBoundCidrsRequest handles app-role-write-secret-id-bound-cidrs operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs
func (s *Server) handleAppRoleWriteSecretIDBoundCidrsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-secret-id-bound-cidrs"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteSecretIDBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteSecretIDBoundCidrs",
			ID:   "app-role-write-secret-id-bound-cidrs",
		}
	)
	params, err := decodeAppRoleWriteSecretIDBoundCidrsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteSecretIDBoundCidrsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteSecretIDBoundCidrsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteSecretIDBoundCidrs",
			OperationSummary: "",
			OperationID:      "app-role-write-secret-id-bound-cidrs",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteSecretIdBoundCidrsRequest
			Params   = AppRoleWriteSecretIDBoundCidrsParams
			Response = *AppRoleWriteSecretIDBoundCidrsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteSecretIDBoundCidrsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWriteSecretIDBoundCidrs(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWriteSecretIDBoundCidrs(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteSecretIDBoundCidrsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteSecretIDNumUsesRequest handles app-role-write-secret-id-num-uses operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses
func (s *Server) handleAppRoleWriteSecretIDNumUsesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-secret-id-num-uses"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteSecretIDNumUses",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteSecretIDNumUses",
			ID:   "app-role-write-secret-id-num-uses",
		}
	)
	params, err := decodeAppRoleWriteSecretIDNumUsesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteSecretIDNumUsesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteSecretIDNumUsesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteSecretIDNumUses",
			OperationSummary: "",
			OperationID:      "app-role-write-secret-id-num-uses",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteSecretIdNumUsesRequest
			Params   = AppRoleWriteSecretIDNumUsesParams
			Response = *AppRoleWriteSecretIDNumUsesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteSecretIDNumUsesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWriteSecretIDNumUses(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWriteSecretIDNumUses(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteSecretIDNumUsesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteSecretIDTTLRequest handles app-role-write-secret-id-ttl operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/secret-id-ttl
func (s *Server) handleAppRoleWriteSecretIDTTLRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-secret-id-ttl"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteSecretIDTTL",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteSecretIDTTL",
			ID:   "app-role-write-secret-id-ttl",
		}
	)
	params, err := decodeAppRoleWriteSecretIDTTLParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteSecretIDTTLRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteSecretIDTTLNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteSecretIDTTL",
			OperationSummary: "",
			OperationID:      "app-role-write-secret-id-ttl",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteSecretIdTtlRequest
			Params   = AppRoleWriteSecretIDTTLParams
			Response = *AppRoleWriteSecretIDTTLNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteSecretIDTTLParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWriteSecretIDTTL(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWriteSecretIDTTL(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteSecretIDTTLResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteTokenBoundCidrsRequest handles app-role-write-token-bound-cidrs operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs
func (s *Server) handleAppRoleWriteTokenBoundCidrsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-token-bound-cidrs"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteTokenBoundCidrs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteTokenBoundCidrs",
			ID:   "app-role-write-token-bound-cidrs",
		}
	)
	params, err := decodeAppRoleWriteTokenBoundCidrsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteTokenBoundCidrsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteTokenBoundCidrsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteTokenBoundCidrs",
			OperationSummary: "",
			OperationID:      "app-role-write-token-bound-cidrs",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteTokenBoundCidrsRequest
			Params   = AppRoleWriteTokenBoundCidrsParams
			Response = *AppRoleWriteTokenBoundCidrsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteTokenBoundCidrsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWriteTokenBoundCidrs(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWriteTokenBoundCidrs(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteTokenBoundCidrsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteTokenMaxTTLRequest handles app-role-write-token-max-ttl operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/token-max-ttl
func (s *Server) handleAppRoleWriteTokenMaxTTLRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-token-max-ttl"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteTokenMaxTTL",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteTokenMaxTTL",
			ID:   "app-role-write-token-max-ttl",
		}
	)
	params, err := decodeAppRoleWriteTokenMaxTTLParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteTokenMaxTTLRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteTokenMaxTTLNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteTokenMaxTTL",
			OperationSummary: "",
			OperationID:      "app-role-write-token-max-ttl",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteTokenMaxTtlRequest
			Params   = AppRoleWriteTokenMaxTTLParams
			Response = *AppRoleWriteTokenMaxTTLNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteTokenMaxTTLParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWriteTokenMaxTTL(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWriteTokenMaxTTL(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteTokenMaxTTLResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteTokenNumUsesRequest handles app-role-write-token-num-uses operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/token-num-uses
func (s *Server) handleAppRoleWriteTokenNumUsesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-token-num-uses"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-num-uses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteTokenNumUses",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteTokenNumUses",
			ID:   "app-role-write-token-num-uses",
		}
	)
	params, err := decodeAppRoleWriteTokenNumUsesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteTokenNumUsesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteTokenNumUsesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteTokenNumUses",
			OperationSummary: "",
			OperationID:      "app-role-write-token-num-uses",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteTokenNumUsesRequest
			Params   = AppRoleWriteTokenNumUsesParams
			Response = *AppRoleWriteTokenNumUsesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteTokenNumUsesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWriteTokenNumUses(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWriteTokenNumUses(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteTokenNumUsesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppRoleWriteTokenTTLRequest handles app-role-write-token-ttl operation.
//
// POST /auth/{approle_mount_path}/role/{role_name}/token-ttl
func (s *Server) handleAppRoleWriteTokenTTLRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("app-role-write-token-ttl"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/auth/{approle_mount_path}/role/{role_name}/token-ttl"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppRoleWriteTokenTTL",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppRoleWriteTokenTTL",
			ID:   "app-role-write-token-ttl",
		}
	)
	params, err := decodeAppRoleWriteTokenTTLParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppRoleWriteTokenTTLRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AppRoleWriteTokenTTLNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AppRoleWriteTokenTTL",
			OperationSummary: "",
			OperationID:      "app-role-write-token-ttl",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "role_name",
					In:   "path",
				}: params.RoleName,
				{
					Name: "approle_mount_path",
					In:   "path",
				}: params.ApproleMountPath,
			},
			Raw: r,
		}

		type (
			Request  = *AppRoleWriteTokenTtlRequest
			Params   = AppRoleWriteTokenTTLParams
			Response = *AppRoleWriteTokenTTLNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppRoleWriteTokenTTLParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppRoleWriteTokenTTL(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.AppRoleWriteTokenTTL(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppRoleWriteTokenTTLResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2ConfigureRequest handles kv-v2-configure operation.
//
// Configure backend level settings that are applied to every key in the key-value store.
//
// POST /{kv_v2_mount_path}/config
func (s *Server) handleKvV2ConfigureRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-configure"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/config"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2Configure",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2Configure",
			ID:   "kv-v2-configure",
		}
	)
	params, err := decodeKvV2ConfigureParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeKvV2ConfigureRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *KvV2ConfigureNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2Configure",
			OperationSummary: "Configure backend level settings that are applied to every key in the key-value store.",
			OperationID:      "kv-v2-configure",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = *KvV2ConfigureRequest
			Params   = KvV2ConfigureParams
			Response = *KvV2ConfigureNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2ConfigureParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.KvV2Configure(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.KvV2Configure(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2ConfigureResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2DeleteRequest handles kv-v2-delete operation.
//
// DELETE /{kv_v2_mount_path}/data/{path}
func (s *Server) handleKvV2DeleteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-delete"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/data/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2Delete",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2Delete",
			ID:   "kv-v2-delete",
		}
	)
	params, err := decodeKvV2DeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *KvV2DeleteNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2Delete",
			OperationSummary: "",
			OperationID:      "kv-v2-delete",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "path",
					In:   "path",
				}: params.Path,
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = KvV2DeleteParams
			Response = *KvV2DeleteNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2DeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.KvV2Delete(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.KvV2Delete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2DeleteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2DeleteMetadataAndAllVersionsRequest handles kv-v2-delete-metadata-and-all-versions operation.
//
// DELETE /{kv_v2_mount_path}/metadata/{path}
func (s *Server) handleKvV2DeleteMetadataAndAllVersionsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-delete-metadata-and-all-versions"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/metadata/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2DeleteMetadataAndAllVersions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2DeleteMetadataAndAllVersions",
			ID:   "kv-v2-delete-metadata-and-all-versions",
		}
	)
	params, err := decodeKvV2DeleteMetadataAndAllVersionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *KvV2DeleteMetadataAndAllVersionsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2DeleteMetadataAndAllVersions",
			OperationSummary: "",
			OperationID:      "kv-v2-delete-metadata-and-all-versions",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "path",
					In:   "path",
				}: params.Path,
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = KvV2DeleteMetadataAndAllVersionsParams
			Response = *KvV2DeleteMetadataAndAllVersionsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2DeleteMetadataAndAllVersionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.KvV2DeleteMetadataAndAllVersions(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.KvV2DeleteMetadataAndAllVersions(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2DeleteMetadataAndAllVersionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2DeleteVersionsRequest handles kv-v2-delete-versions operation.
//
// POST /{kv_v2_mount_path}/delete/{path}
func (s *Server) handleKvV2DeleteVersionsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-delete-versions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/delete/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2DeleteVersions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2DeleteVersions",
			ID:   "kv-v2-delete-versions",
		}
	)
	params, err := decodeKvV2DeleteVersionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeKvV2DeleteVersionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *KvV2DeleteVersionsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2DeleteVersions",
			OperationSummary: "",
			OperationID:      "kv-v2-delete-versions",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "path",
					In:   "path",
				}: params.Path,
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = *KvV2DeleteVersionsRequest
			Params   = KvV2DeleteVersionsParams
			Response = *KvV2DeleteVersionsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2DeleteVersionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.KvV2DeleteVersions(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.KvV2DeleteVersions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2DeleteVersionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2DestroyVersionsRequest handles kv-v2-destroy-versions operation.
//
// POST /{kv_v2_mount_path}/destroy/{path}
func (s *Server) handleKvV2DestroyVersionsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-destroy-versions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/destroy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2DestroyVersions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2DestroyVersions",
			ID:   "kv-v2-destroy-versions",
		}
	)
	params, err := decodeKvV2DestroyVersionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeKvV2DestroyVersionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *KvV2DestroyVersionsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2DestroyVersions",
			OperationSummary: "",
			OperationID:      "kv-v2-destroy-versions",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "path",
					In:   "path",
				}: params.Path,
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = *KvV2DestroyVersionsRequest
			Params   = KvV2DestroyVersionsParams
			Response = *KvV2DestroyVersionsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2DestroyVersionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.KvV2DestroyVersions(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.KvV2DestroyVersions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2DestroyVersionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2ListRequest handles kv-v2-list operation.
//
// GET /{kv_v2_mount_path}/metadata/{path}/
func (s *Server) handleKvV2ListRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-list"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/metadata/{path}/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2List",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2List",
			ID:   "kv-v2-list",
		}
	)
	params, err := decodeKvV2ListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *StandardListResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2List",
			OperationSummary: "",
			OperationID:      "kv-v2-list",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "list",
					In:   "query",
				}: params.List,
				{
					Name: "path",
					In:   "path",
				}: params.Path,
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = KvV2ListParams
			Response = *StandardListResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2ListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.KvV2List(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.KvV2List(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2ListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2ReadRequest handles kv-v2-read operation.
//
// GET /{kv_v2_mount_path}/data/{path}
func (s *Server) handleKvV2ReadRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-read"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/data/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2Read",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2Read",
			ID:   "kv-v2-read",
		}
	)
	params, err := decodeKvV2ReadParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *KvV2ReadResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2Read",
			OperationSummary: "",
			OperationID:      "kv-v2-read",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "path",
					In:   "path",
				}: params.Path,
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = KvV2ReadParams
			Response = *KvV2ReadResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2ReadParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.KvV2Read(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.KvV2Read(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2ReadResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2ReadConfigurationRequest handles kv-v2-read-configuration operation.
//
// Read the backend level settings.
//
// GET /{kv_v2_mount_path}/config
func (s *Server) handleKvV2ReadConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-read-configuration"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/config"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2ReadConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2ReadConfiguration",
			ID:   "kv-v2-read-configuration",
		}
	)
	params, err := decodeKvV2ReadConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *KvV2ReadConfigurationResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2ReadConfiguration",
			OperationSummary: "Read the backend level settings.",
			OperationID:      "kv-v2-read-configuration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = KvV2ReadConfigurationParams
			Response = *KvV2ReadConfigurationResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2ReadConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.KvV2ReadConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.KvV2ReadConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2ReadConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2ReadMetadataRequest handles kv-v2-read-metadata operation.
//
// GET /{kv_v2_mount_path}/metadata/{path}
func (s *Server) handleKvV2ReadMetadataRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-read-metadata"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/metadata/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2ReadMetadata",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2ReadMetadata",
			ID:   "kv-v2-read-metadata",
		}
	)
	params, err := decodeKvV2ReadMetadataParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *KvV2ReadMetadataResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2ReadMetadata",
			OperationSummary: "",
			OperationID:      "kv-v2-read-metadata",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "path",
					In:   "path",
				}: params.Path,
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = KvV2ReadMetadataParams
			Response = *KvV2ReadMetadataResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2ReadMetadataParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.KvV2ReadMetadata(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.KvV2ReadMetadata(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2ReadMetadataResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2ReadSubkeysRequest handles kv-v2-read-subkeys operation.
//
// GET /{kv_v2_mount_path}/subkeys/{path}
func (s *Server) handleKvV2ReadSubkeysRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-read-subkeys"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/subkeys/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2ReadSubkeys",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2ReadSubkeys",
			ID:   "kv-v2-read-subkeys",
		}
	)
	params, err := decodeKvV2ReadSubkeysParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *KvV2ReadSubkeysResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2ReadSubkeys",
			OperationSummary: "",
			OperationID:      "kv-v2-read-subkeys",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "path",
					In:   "path",
				}: params.Path,
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = KvV2ReadSubkeysParams
			Response = *KvV2ReadSubkeysResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2ReadSubkeysParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.KvV2ReadSubkeys(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.KvV2ReadSubkeys(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2ReadSubkeysResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2UndeleteVersionsRequest handles kv-v2-undelete-versions operation.
//
// POST /{kv_v2_mount_path}/undelete/{path}
func (s *Server) handleKvV2UndeleteVersionsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-undelete-versions"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/undelete/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2UndeleteVersions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2UndeleteVersions",
			ID:   "kv-v2-undelete-versions",
		}
	)
	params, err := decodeKvV2UndeleteVersionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeKvV2UndeleteVersionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *KvV2UndeleteVersionsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2UndeleteVersions",
			OperationSummary: "",
			OperationID:      "kv-v2-undelete-versions",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "path",
					In:   "path",
				}: params.Path,
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = *KvV2UndeleteVersionsRequest
			Params   = KvV2UndeleteVersionsParams
			Response = *KvV2UndeleteVersionsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2UndeleteVersionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.KvV2UndeleteVersions(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.KvV2UndeleteVersions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2UndeleteVersionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2WriteRequest handles kv-v2-write operation.
//
// POST /{kv_v2_mount_path}/data/{path}
func (s *Server) handleKvV2WriteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-write"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/data/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2Write",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2Write",
			ID:   "kv-v2-write",
		}
	)
	params, err := decodeKvV2WriteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeKvV2WriteRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *KvV2WriteResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2Write",
			OperationSummary: "",
			OperationID:      "kv-v2-write",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "path",
					In:   "path",
				}: params.Path,
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = *KvV2WriteRequest
			Params   = KvV2WriteParams
			Response = *KvV2WriteResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2WriteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.KvV2Write(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.KvV2Write(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2WriteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleKvV2WriteMetadataRequest handles kv-v2-write-metadata operation.
//
// POST /{kv_v2_mount_path}/metadata/{path}
func (s *Server) handleKvV2WriteMetadataRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("kv-v2-write-metadata"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/{kv_v2_mount_path}/metadata/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "KvV2WriteMetadata",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "KvV2WriteMetadata",
			ID:   "kv-v2-write-metadata",
		}
	)
	params, err := decodeKvV2WriteMetadataParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeKvV2WriteMetadataRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *KvV2WriteMetadataNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "KvV2WriteMetadata",
			OperationSummary: "",
			OperationID:      "kv-v2-write-metadata",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "path",
					In:   "path",
				}: params.Path,
				{
					Name: "kv_v2_mount_path",
					In:   "path",
				}: params.KvV2MountPath,
			},
			Raw: r,
		}

		type (
			Request  = *KvV2WriteMetadataRequest
			Params   = KvV2WriteMetadataParams
			Response = *KvV2WriteMetadataNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackKvV2WriteMetadataParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.KvV2WriteMetadata(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.KvV2WriteMetadata(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeKvV2WriteMetadataResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
